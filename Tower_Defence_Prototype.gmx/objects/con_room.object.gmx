<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-400</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>other</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>global.spawner_1_exists = false; //for initialization. MAKE SURE THAT THE con_room OBJECT IS CREATED BEFORE THE OBJ_SPAWNER_1 OBJECT IS CREATED OR THIS WILL OVERWRITE IT!!!!

global.current_tower_cost = 0; //later changed in the UI_tower draw event

global.draw_paused_string = false; //also in con_UI create event

//tower starting stats:

tower_normal_start_damage = 8;
tower_normal_start_speed = 35;

tower_oil_start_damage = 8;
tower_oil_start_speed = 75;
tower_oil_start_burn_duration = 130;

tower_rock_start_damage = 16;
tower_rock_start_speed = 120;


//for path_sequence logic:
alarm[0] = 4;

draw_place_tower_arrow = false;

global.countdown = 0;

global.gold = 0; //changed later in the waves controller

level_win_set = false;;

global.treasure_chance = 30;
//global.treasure_chance = 60;

global.room_towers = 0;

global.create_waves_controller = true; //see obj_home
global.how_many_groups_left = 10; //must be above 0; 

global.map_total_enemies_screen = 0;
global.map_cur_enemy = 0; //used to identify the enemies

global.enemy_id[max_enemies] = 0; // initialize the array
global.enemy_id_exists[max_enemies] = false; //initialize the array

global.missiles_on_screen = 0;
global.shots_fired = 0;

global.wave = 0;
global.enemies_killed = 0;


timer_pos = false;
timer_neg = false;

my_mouse = instance_create(x,y,obj_mouse);

instance_create(x,y,con_UI);


place_tower = false;
place_tower_type = tower_empty;


global.tower_id[max_towers] = 0; //initialize the array
tower_id_pointer = 0; //incremented each time a tower is created. 
my_tower = 0; //later stores the instance ID (pointer) of each tower instance before assigning it to the array tower_id. 

global.selected_tower_id = 0; //stores the currently_selected_tower id
global.selected_tower_name = " "; // later used to store the string of a selected tower
global.selected_tower_range = 0;
global.selected_tower_rate_of_fire = 0;
global.selected_tower_damage = 0;
global.selected_tower_sell_amount = 0;
global.selected_tower_nickname = "";

global.home_max_health = 100;
global.home_health = global.home_max_health;
game_over_set = false;

//grid for snapping:
legal_placement = false;

grid = 32;
max_x_tiles = (global.bar_outer_x1/grid); //only draws up to the bar
max_y_tiles = (room_height/grid);
max_grid_objects = max_x_tiles*max_y_tiles;
global.grid_array[max_grid_objects] = 0; //initialize 


place_grid_x = 0;
place_grid_y = 0;

//create all of the tiles:
for (i = 1; i &lt;= (max_y_tiles + 1); i++){ //must use + 1 because of the array below
    for (j = 1; j &lt;= (max_x_tiles + 1); j++){ //must use + 1 because of the array below
        global.grid_array[j + (max_x_tiles * (i - 1) )] = instance_create(-16 + grid*j, -16 + grid*i, obj_grid);
        global.grid_array[j + (max_x_tiles * (i - 1) )].local_id = j + (max_x_tiles * (i - 1) );
    }
}

place_hut_legal = false; //see step event
debug_place_hut = false;

place_hut_direction = face_right;

global.hover_over_upgrade = false;

place_legal_color = c_green;


</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>instance_create(global.first_path_x,global.first_path_y,obj_path_holder0);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>


if (!global.freeze) {
    
    //add timer gold:
    var stretch_graph = (global.time_sec * 8)
    if ( (sin_loop(stretch_graph) == 1) &amp;&amp; (timer_neg) ) timer_pos = true;
    if (sin_loop(stretch_graph) == -1) timer_neg = true;
    
    if (timer_pos) {
        global.gold += round( (round(1 + (global.wave/2)) )*room_speed/60);
        timer_pos = false;
        timer_neg = false;
        
        if (global.countdown &gt; 0) global.countdown = max( global.countdown - round(60*(room_speed/60)), 0);
        
    }
    
    
    
    
    //grabbing towers off of the purchase bar, and placing them on the map:
    //see below for logic on enabling place tower:
    if (place_tower) {
    
        obj_mouse.right_click_to_cancel_display = true;
    
        place_grid_x = current_tile.x; //snaps to the grid. 
        place_grid_y = current_tile.y;
    
        with (obj_mouse_tip) {
        
            if (place_meeting(x, y, obj_illegal_placement) ){
                con_room.legal_placement = false;
            } else con_room.legal_placement = true;
        }
        
        //these need to stay outside of the if statement below:
        //var new_place_x;
        //var new_place_y;
        
        if (place_tower_type = tower_hut){
        
            debug_place_hut = true; //also delete else statement when finished using!
            
            
                //logic for placing tower adjacent to road types:
    
            with (current_tile) {
                var check_distance = 32;
                
                //NOTICE THIS DOES NOT ACCOUNT FOR ALLYWAYS!!!!!
                //tile is on the right
                if (place_meeting(x + check_distance, y, obj_tile_parent) ){ //check right
                    con_room.place_hut_direction = face_right;
                    con_room.place_hut_legal = true;
                }
                
                //down
                else if (place_meeting(x, y + check_distance, obj_tile_parent) ){ //check down
                    con_room.place_hut_direction = face_down;
                    con_room.place_hut_legal = true;
                }
                
                //left
                else if (place_meeting(x - check_distance, y, obj_tile_parent) ){ //check left
                    con_room.place_hut_direction = face_left;
                    con_room.place_hut_legal = true;
                }
                    
                //up
                else if (place_meeting(x, y - check_distance, obj_tile_parent) ){ //check up
                    con_room.place_hut_direction = face_up;
                    con_room.place_hut_legal = true;
                }
                else con_room.legal_placement = false; 
            }
    
            
        } else debug_place_hut = false;
    
        
        //CANCEL THE PURCHASE:
        if (mouse_check_button_pressed(mb_right)){
            place_tower = false;
            obj_mouse.right_click_to_cancel_display = false;
            with (con_room.my_arrow) instance_destroy();
        }
        
        
        //PLACE THE SELECTED TOWER!
        if ( (mouse_check_button_pressed(mb_left)) &amp;&amp; (mouse_x &lt; global.bar_outer_x1) &amp;&amp; (legal_placement) ){
        
            
    
            switch (place_tower_type) {
                case tower_normal: 
                    my_tower = instance_create(place_grid_x, place_grid_y, obj_tower);
                    my_tower.tower_type = tower_normal;
                    break;
                    
                case tower_rock: 
                    my_tower = instance_create(place_grid_x, place_grid_y, obj_tower_rock);
                    my_tower.tower_type = tower_rock;
                    break;
                    
                case tower_oil: 
                    my_tower = instance_create(place_grid_x, place_grid_y, obj_tower_oil); 
                    my_tower.tower_type = tower_oil;
                    break;
                    
                    
                    
                case tower_hut: 
                    //if there was a wall:
                    if (place_hut_legal){
                        my_tower = instance_create(place_grid_x, place_grid_y, obj_barracks_spawner); //later create the green tower
                        my_tower.my_direction = place_hut_direction;
                        place_hut_legal = false;
                    }
                    
                    break;
            }
            
            //store the id of the tower into an array of pointers so that we can access the towers information
            //to be displayed in the Current Tower bar. And also so we can edit the towers properties. 
            tower_id[tower_id_pointer] = my_tower.id; //stores the id of the created tower into the id array
            my_tower.local_tower_id = tower_id_pointer // just an integer number stored in the tower to represent it's id. 
            tower_id_pointer++; //the next tower will hold the next element of the id array. 
            
            global.gold -= global.current_tower_cost;  //comes from UI_tower object draw event
            global.room_towers += 1;
            place_tower = false;
            obj_mouse.right_click_to_cancel_display = false;
            with (con_room.my_arrow) instance_destroy();
        }
    }
    
    
    
    
    //Enemies do damage to home health
        //obj enemy, or each instance seperately? I should put this in the obj_enemy code...
    with (obj_enemy) {
        if (place_meeting(x, y, obj_home)) {
            my_heart = instance_create(x,y-16, obj_heart_float)
            my_heart.damage = my_damage;
            global.home_health -= my_damage;
            obj_home.my_color = c_red; //later use color blending to mix the red with the white like alpha. 
            obj_home.alarm[0] = obj_home.home_health_timer;
            obj_home.draw_home_healthbar = true;
            obj_home.draw_home_healthbar_alpha = 1;
            obj_home.start_fade = false;
            obj_home.alarm[1] = obj_home.start_fade_timer; //time before start fade timer begins
            
            gold_bag = instance_create(x,y - 8, obj_goldfind);
                            //gold_reward is half for enemies that explode at home
            var gold_amount = round(gold_reward/2); //multiply this number by wave number? (for more gold later?)
            gold_bag.gold_amount = gold_amount;
            
            global.gold += gold_amount;
            
            instance_destroy();
        }
        
        
        if (place_meeting(x, y, obj_home1)) {
            my_heart = instance_create(x,y-16, obj_heart_float)
            my_heart.damage = my_damage;
            global.home_health -= my_damage;
            obj_home1.my_color = c_red; //later use color blending to mix the red with the white like alpha. 
            obj_home1.alarm[0] = obj_home.home_health_timer;
            obj_home1.draw_home_healthbar = true;
            obj_home1.draw_home_healthbar_alpha = 1;
            obj_home1.start_fade = false;
            obj_home1.alarm[1] = obj_home.start_fade_timer; //time before start fade timer begins
            
            gold_bag = instance_create(x,y - 8, obj_goldfind);
                            //gold_reward is half for enemies that explode at home
            var gold_amount = round(gold_reward/2); //multiply this number by wave number? (for more gold later?)
            gold_bag.gold_amount = gold_amount;
            
            global.gold += gold_amount;
            
            instance_destroy();
        }
        
        //or home1:
        
        
        
    }
    
    
    
} //if (!global.freeze)






//game over-----------------------------------------------------
if (global.home_health &lt;= 0) &amp;&amp; (!game_over_set){
    
    
    my_game_lose = instance_create(room_width/2, room_height, obj_game_lose);
    my_game_lose.enemies_killed = global.enemies_killed;
    my_game_lose.shots_fired = global.shots_fired;
    my_game_lose.waves_completed = global.wave;
    
    global.freeze = true;
    global.level_end_timer = (get_timer()/1000000) - global.level_begin_timer - global.paused_time_total; //get the current time so that we can subtract that time to reset our rooms timer
    game_over_set = true;
    
    //make the following buttons, and make them have nice alpha and color fading with mouse_over and click:
    //instance_create(x,y, obj_restart_button);
    //instance_create(x,y, obj_quit_button);
}



//game over
if (game_over_set) {
    
            //restart game button
    with (obj_game_restart_button) {
        if (collision_rectangle(click_x1, click_y1, click_x2, click_y2, obj_mouse_tip, true, true)) {
        
            if (mouse_check_button(mb_left)) {
                my_color = c_lime;
            }
            else my_color = c_green;
            if (mouse_check_button_released(mb_left)) {
            //restart level
            room_restart(); 
            }
        }
        else my_color = c_white;
    }
            //quit game button
    with (obj_game_quit_button) {
        if (collision_rectangle(click_x1, click_y1, click_x2, click_y2, obj_mouse_tip, true, true)) {
        
            if (mouse_check_button(mb_left)) {
                my_color = c_red;
            }
            else my_color = c_maroon;
            if (mouse_check_button_released(mb_left)) {
            //quit
            game_end();
            }
        }
        else my_color = c_white;
    }
}




//level win
if (level_win_set) {

            //next level button
    with (obj_game_next_level_button) {
        if (collision_rectangle(click_x1, click_y1, click_x2, click_y2, obj_mouse_tip, true, true)) {
        
            if (mouse_check_button(mb_left)) {
                my_color = c_lime;
            }
            else my_color = c_green;
            if (mouse_check_button_released(mb_left)) {
            
            //LATER CREATE A CONDITION FOR WINNING THE GAME! (no more rooms)
            //next level
            room_goto_next();
            }
        }
        else my_color = c_white;
    }
            //quit game button
    with (obj_game_quit_button) {
        if (collision_rectangle(click_x1, click_y1, click_x2, click_y2, obj_mouse_tip, true, true)) {
        
            if (mouse_check_button(mb_left)) {
                my_color = c_red;
            }
            else my_color = c_maroon;
            if (mouse_check_button_released(mb_left)) {
            //quit
            game_end();
            }
        }
        else my_color = c_white;
    }

}

//click on upgrades to purchase them:
//(see obj_upgrade)



//cheats
if (keyboard_check_pressed(vk_enter)) {
    if (!global.freeze) global.freeze = true;
    else global.freeze = false;
    
    if (!global.draw_paused_string) global.draw_paused_string = true;
    else global.draw_paused_string = false;
    
}


if (keyboard_check_pressed(ord("G"))) {
    global.gold += 200;
}

if (keyboard_check_pressed(ord("R"))) {
    room_restart();
}

if (keyboard_check_pressed(ord("F"))) {
    my_firework = instance_create(mouse_x,mouse_y,obj_firework);
    my_firework.gold_amount = choose(10,123,5432);
}


if (keyboard_check_pressed(ord("W"))) {
    instance_create(mouse_x, mouse_y-8, obj_ground_fire); 
}

if (keyboard_check_pressed(vk_right)) {
    if (room_next(room) != -1) {
        room_goto(room_next(room));
    }
}

if (keyboard_check_pressed(vk_left)) {
    if (room_previous(room) != -1) {
        room_goto(room_previous(room));
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="4">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>global.freeze = false; //used to freeze the game when victory or lose conditions are met. 

//current room switch for obj_waves_controller create event switch

cur_room = room;

switch (cur_room) {

    case rm_level_1:
        global.level = 1;
        break;

    case rm_level_2:
        global.level = 2;
        break;
        
    case rm_level_3:
        global.level = 3;
        break;

    case rm_level_4:
        global.level = 4;
        break;
        
    case rm_level_5:
        global.level = 4;
        break;
        
    default:
        global.level = 1;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>randomize();

current_tile = 0; //a easy but perhaps bad fix for the bug that occurs when the tile does not initialize
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>





//make grid units and store them in the grid unit array for collision checking

if (!global.freeze) {
    
    if (legal_placement) place_legal_color = c_green;
    else place_legal_color = c_red;
    
    
    image_speed = 0;
    //placing towers
    if (place_tower){
        switch (place_tower_type) {
            case tower_normal: 
            draw_sprite_ext( spr_tower_normal, image_index, place_grid_x, place_grid_y - 32, 1, 1, 0, place_legal_color, 0.7);
                draw_set_alpha(0.08);
                draw_circle_colour(place_grid_x, place_grid_y, tower_start_range, c_lime, c_lime, false); 
                draw_set_alpha(1);   
                break;
            
            case tower_rock: 
                draw_sprite_ext( spr_tower_rock, image_index, place_grid_x, place_grid_y - 32, 1, 1, 0, place_legal_color, 0.7);
                draw_set_alpha(0.08);
                draw_circle_colour(place_grid_x, place_grid_y, tower_rock_start_range, c_lime, c_lime, false); 
                draw_set_alpha(1);   
                break;
            
            case tower_oil: 
                draw_sprite_ext( spr_tower_oil, image_index, place_grid_x, place_grid_y - 32, 1, 1, 0, place_legal_color, 0.7);
                draw_set_alpha(0.08);
                draw_circle_colour(place_grid_x, place_grid_y, tower_oil_start_range, c_lime, c_lime, false); 
                draw_set_alpha(1);   
                break;
                
            case tower_hut: 
                //later only place the hut using the appropriate new_x and new_y variables.
                draw_sprite_ext( spr_hut, image_index, place_grid_x, place_grid_y - 32, 1, 1, 0, place_legal_color, 0.7);
                break;
                
            
            default:
        }
        
        if (draw_place_tower_arrow)
            //DON'T FORGET TO DELETE
            my_arrow = instance_create(mouse_x,mouse_y, obj_place_tower_arrow);
            draw_place_tower_arrow = false;
        
    }


} //if (!global.freeze)






//debug
/*
var k1 = (global.time_sec * 8)
var k2 = sin_loop(k1)

draw_text(mouse_x, mouse_y - 16, "sin_loop(stretch_graph) = " + string(k2) );


//Debugging
draw_set_colour(c_black);
draw_rectangle(0, room_height, (256 + 128), room_height - 16*4 + 8, false);


draw_set_colour(c_white);
draw_text(16, room_height - 16, "globlal.map_total_enemies_screen = " + string(global.map_total_enemies_screen) );

draw_text(16, room_height - 16*2, "map_cur_enemy = " + string(global.map_cur_enemy) );

draw_text(16, room_height - 16*3, "Total Missiles on Screen = " + string(global.missiles_on_screen) );

draw_set_colour(c_black);


*/




</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
