<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_dude</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-5</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>obj_enemy</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//ALL IN THE SCRIPTS NOW!!!!

/*
alarm[0] = col_check; //this alarm is the collision checking alarm. 

starting_position_x = x;
starting_position_y = y;

my_path = instance_create(x,y, obj_pathfind);
killed_by_tower = false;
looking_for_fight = true;
fighting = false;


//the following are changed by the spawner, depending on what kind of unit we want to spawn:
max_health = 100;
my_move_speed = 25;
move_distance = 25;

my_sprite = spr_dude;
sprite_scale = 1;
my_color = c_white;

my_damage = 15;

*/


</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>global.enemy_id_exists[local_id] = false; //set it's state to being "dead" from our array. 

global.map_total_enemies_screen--;

if (killed_by_tower){
    global.enemies_killed += 1;
    
    if (is_treasure_enemy) gold_bag = instance_create(x,y - 8, obj_firework);
    else gold_bag = instance_create(x,y - 8, obj_goldfind);
    
                    //gold_reward is a variable given to this object by the spawner
    var gold_amount = gold_reward + choose(0,1,2,3); //multiply this number by wave number? (for more gold later?)
    gold_bag.gold_amount = gold_amount
    
    global.gold += gold_amount

}

if (fighting &amp;&amp; (instance_exists(my_hero_target)) ) {
    my_hero_target.looking_for_fight = true;
    my_hero_target.fighting = false;
}

if (is_treasure_enemy &amp;&amp; !indicator_destroyed) {
    with (my_treasure_indicator) instance_destroy();
}


with (my_path) instance_destroy();
is_dead = true;



</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="7">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///apply fire damage

if (!global.freeze) {

    if (fire_alarm &gt; 0) {
    
    
        //more damage towards the beginning of the burn
        
        var fire_alarm_perc = fire_alarm/fire_alarm_max
        var add_damage_for_longer_duration = max( ( (fire_alarm_max)/60), 1) //every second added means 1 extra damage per burn
        var damage_amount = (fire_alarm_perc)*(add_damage_for_longer_duration); //longer burn, more damage
        
        my_health -= round(fire_damage + damage_amount + fire_size); //fire size is one damage per sprite scale
        
        
        //create smoke on the enemy when on fire
        for (i = choose(1,2,3); i &gt; 0; i--) {
            my_smoke = instance_create(x,y-8,obj_smoke);
            my_smoke.my_scale = max(sprite_scale*8, 4); 
            
            var deviance = (choose(1.25,1,0.75,0.5));
            
            my_smoke.max_life = (60*2)*deviance;
            my_smoke.my_max_life = my_smoke.max_life/deviance;
            my_smoke.life = my_smoke.my_max_life;
            
            my_smoke.life_perc = my_smoke.life/my_smoke.my_max_life;
            
            my_smoke.alarm[0] = my_smoke.leave_trails;
        }
        
        
        
    }

}

alarm[7] = fire_check_alarm;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="6">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///check if stuck

if (!global.freeze) {

    //don't run the code if stunned
    if (stun_duration == 0) {
    
        //compare to the last time the alarm went off:
        if (distance_to_point(x_previous, y_previous) &lt;= 3) is_stuck = true;
        else {
            is_stuck = false;
            check_stuck_again = false;   
            draw_exclamation = false;
        }
        
        //if STILL stuck, teleport to the nearest road tile.
        if (check_stuck_again) {
            closest_road = instance_nearest(x,y,obj_tile_parent);
            my_path.x = closest_road.x;
            my_path.y = closest_road.y;
            x = closest_road.x;
            y = closest_road.y;
            is_stuck = false;
            check_stuck_again = false; 
            draw_exclamation = false;
        }
        
        //draw an exclamation
        if (is_stuck) {
            draw_exclamation = true;
            check_stuck_again = true;
        }
        
        //store the current_x
        x_previous = x;
        y_previous = y;
    
    }

}

//run the alarm AFTER being stunned
alarm[6] = is_stuck_alarm_check + stun_duration;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="5">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//reset stun duration
stun_duration = 0;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="4">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>sprinter_amount = sprinter_amount_off;
draw_sprint_icon = false;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="3">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>

if (sprinter_amount_on &gt; 0){

    //the unit is now sprinting
    sprinter_amount = sprinter_amount_on;
    draw_sprint_icon = true;
    
    //reset the alarm for sprinting
    alarm[4] = sprinter_alarm_off;
    
    //reset this alarm
    alarm[3] = sprinter_alarm_on;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Sheilders, Healers, Hoard Units


if (shielder) {

    //Enemy Cycling:
    for (enemy_pointer = 0; enemy_pointer &lt; global.map_cur_enemy; enemy_pointer++){
        //cycle through each enemy
    
        //skip myself
        if (global.enemy_id[enemy_pointer] == id) continue;
        
        if (global.enemy_id_exists[enemy_pointer] = true){ //skip this if the object does not exist any longer. (stored in a seperate boolean array)
            
            
            //every enemy checks if it has a shield or not, so that if it doesn't, it's shield is reset to none. 
            global.enemy_id[enemy_pointer].check_shield = true;
            
            
            var distance_to_pointer = distance_to_point(global.enemy_id[enemy_pointer].x, global.enemy_id[enemy_pointer].y);
            if (distance_to_pointer &lt; sheild_radius){ //nearest enemy
                //if within range:
                global.enemy_id[enemy_pointer].add_shield = true;
                global.enemy_id[enemy_pointer].allow_draw_shield = true;
            }
            
            //if not in range, change the add sheild back to 0. 
            else global.enemy_id[enemy_pointer].add_shield = false;
            
            //WARNING FROM ABOVE!! IF MORE THAN ONE SHIELDER ON THE MAP THIS MIGHT CANCEL THE SHIELDING!  
            // If I want to fix this:
            
                //in the con_room object creation code: global.shield_emitter = 0;
                
                //create a obj_shield_emitter object and copy all this code into it's alarm. 
                
                //in the s_spawner add an if statement. with (a): 
                    //if shielder is true, my_shield_emitter = instance_create(x,y,obj_shield_emitter)
                    //my_shield_emitter.my_unit_id = id;
                    //global.shield_emitter_count++
                
                //in the obj_shield_emitter step event: x = my_unit_id.x; y = my_unit_id.y;
                
                // in the con_room object:            
        }
    }
    
}

if (!global.freeze) {
    
    if (healer_amount &gt; 0) {
    
        //Enemy Cycling:
        for (enemy_pointer = 0; enemy_pointer &lt; global.map_cur_enemy; enemy_pointer++){
            //cycle through each enemy
        
            //skip myself
            if (global.enemy_id[enemy_pointer] == id) continue;
            
            if (global.enemy_id_exists[enemy_pointer] = true){ //skip this if the object does not exist any longer. (stored in a seperate boolean array)
                
                
                var distance_to_pointer = distance_to_point(global.enemy_id[enemy_pointer].x, global.enemy_id[enemy_pointer].y);
                if (distance_to_pointer &lt; healer_radius){ //nearest enemy
                    //if within range:
                    global.enemy_id[enemy_pointer].regen = global.enemy_id[enemy_pointer].base_regen + healer_amount;
                    global.enemy_id[enemy_pointer].allow_draw_heal = true;
                }
                
                //if not in range, change the add heal amount back to it's original amount. 
                else {
                    global.enemy_id[enemy_pointer].regen = base_regen;
                    global.enemy_id[enemy_pointer].allow_draw_heal = false;
                
                }
                    
                //WARNING FROM ABOVE!! IF MORE THAN ONE healer ON THE MAP THIS MIGHT CANCEL THE HEALING!  
                // If I want to fix this, fix it the same way I fixed the shielding:
                
                    //in the con_room object creation code: global.shield_emitter = 0;
                    
                    //create a obj_shield_emitter object and copy all this code into it's alarm. 
                    
                    //in the s_spawner add an if statement. with (a): 
                        //if shielder is true, my_shield_emitter = instance_create(x,y,obj_shield_emitter)
                        //my_shield_emitter.my_unit_id = id;
                        //global.shield_emitter_count++
                    
                    //in the obj_shield_emitter step event: x = my_unit_id.x; y = my_unit_id.y;
                    
                    // in the con_room object:            
            }
        }
        
    }

}


if (hoard_amount_per_unit &gt; 0) {

    //Enemy Cycling:
    for (enemy_pointer = 0; enemy_pointer &lt; global.map_cur_enemy; enemy_pointer++){
        //cycle through each enemy
    
        //skip myself
        if (global.enemy_id[enemy_pointer] == id) continue;
        
        if (global.enemy_id_exists[enemy_pointer] = true){ //skip this if the object does not exist any longer. (stored in a seperate boolean array)
            
            
            var distance_to_pointer = distance_to_point(global.enemy_id[enemy_pointer].x, global.enemy_id[enemy_pointer].y);
            if (distance_to_pointer &lt; hoard_radius){ //nearest enemy
                //if within range:
                hoard_counter++
            }
        }
    }
    
    if (hoard_counter &gt; 0) {
        //store the hoard_amount in a variable, then reset it for the next counting:
        hoard_amount = hoard_counter*hoard_amount_per_unit;
        hoard_counter = 0;
        
        allow_draw_hoard = true;
    }
    
}


alarm[2] = shield_check_alarm;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (!global.freeze) {

    ///regen alarm
    if (regen &gt; 0) {
        if (my_health &lt; max_health) {
                        //the min is to cap the healing at max health
            my_health = min(my_health + regen, max_health);
            my_heal_sprite = instance_create(x,y - 16, obj_heal_float);
            my_heal_sprite.heal = regen;
        }
    }

}
    
//always check for regen, in case a healer comes. 
alarm[1] = regen_alarm;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>

/* OLD
var i;

var inc_size = 8; //how precice the checking is



wall_right = false;
wall_down = false;
wall_left = false;
wall_up = false;
set_direction = false;



for (i = 0; i &lt;= 48; i += inc_size){ 
        
    if (place_meeting(x + i, y, obj_boundry) &amp;&amp; (wall_right == false) ){ //check right
        wall_right = true;
        set_direction = true;
    }
    
    else if (place_meeting(x, y + i, obj_boundry) &amp;&amp; (wall_down == false) ){ //check down
        wall_down = true;
        set_direction = true;
    }

    else if (place_meeting(x - i, y, obj_boundry) &amp;&amp; (wall_left == false) ){ //check left
        wall_left = true;
        set_direction = true;
    }
        
    else if (place_meeting(x, y - i, obj_boundry) &amp;&amp; (wall_up == false) ){ //check up
        wall_up = true;
        set_direction = true;
    }
    
}

var wall_count = 0;

if (wall_up) wall_count++
if (wall_down) wall_count++
if (wall_left) wall_count++
if (wall_right) wall_count++





var set_path_logic = true; 

while (set_path_logic){



    if (wall_count == 1){
        // BASIC-----------------------------
    
        if ( (!wall_right) &amp;&amp; (wall_down) &amp;&amp; (wall_left) &amp;&amp; (wall_up) ){ //there is no wall to the right
            my_dir = col_right;
            set_path_logic = false;
        }
        
        else if ( (wall_right) &amp;&amp; (!wall_down) &amp;&amp; (wall_left) &amp;&amp; (wall_up) ){ //there is no wall below
            my_dir = col_down;
            set_path_logic = false;
        }
        
        else if ( (wall_right) &amp;&amp; (wall_down) &amp;&amp; (!wall_left) &amp;&amp; (wall_up) ){  //there is no wall to the left
            my_dir = col_left;
            set_path_logic = false;
        }
        
        else if ( (wall_right) &amp;&amp; (wall_down) &amp;&amp; (wall_left) &amp;&amp; (!wall_up) ){  //there is no wall above
            my_dir = col_up;
            set_path_logic = false;
        }
    }
    

    if (wall_count == 2){
        // Corridors
    
        if ( (wall_right) &amp;&amp; (!wall_down) &amp;&amp; (wall_left) &amp;&amp; (!wall_up) ){ //up and down
            if (last_direction == col_down) my_dir = col_up;
            if (last_direction == col_up) my_dir = col_down;
            
            if ( (last_direction == col_left) || (last_direction == col_right) )
                if (y &lt; obj_home.y) my_dir = col_down;
                else my_dir = col_up;
            set_path_logic = false;
        }

        if ( (!wall_right) &amp;&amp; (wall_down) &amp;&amp; (!wall_left) &amp;&amp; (wall_up) ){ //up and down
            if (last_direction == col_right) my_dir = col_left;
            if (last_direction == col_left) my_dir = col_right;
            
            if ( (last_direction == col_up) || (last_direction == col_down) )
                if (x &lt; obj_home.x) my_dir = col_right;
                else my_dir = col_left;
                
            set_path_logic = false;
        }
    
        // CORNERS-----------------------------
        
        else if ( (!wall_right) &amp;&amp; (!wall_down) &amp;&amp; (wall_left) &amp;&amp; (wall_up) ){ //top left corner
                                                                          //      |-----
                                                                          //      |
                                                                          //      |
            if (last_direction == col_up) my_dir = col_right;
            else my_dir = col_down;
            set_path_logic = false;
        }
        
        else if ( (wall_right) &amp;&amp; (!wall_down) &amp;&amp; (!wall_left) &amp;&amp; (wall_up) ){ //top right corner
                                                                               //      -----|
                                                                               //           |
                                                                               //           |
            if (last_direction == col_right) my_dir = col_down;
            else my_dir = col_left;
            set_path_logic = false;
        }
        
        else if ( (wall_right) &amp;&amp; (wall_down) &amp;&amp; (!wall_left) &amp;&amp; (!wall_up) ){  //bottom right corner
                                                                               //            |
                                                                               //            |
                                                                               //       -----|
            if (last_direction == col_right) my_dir = col_up;
            else my_dir = col_left;
            set_path_logic = false;
        }
        
        else if ( (!wall_right) &amp;&amp; (wall_down) &amp;&amp; (wall_left) &amp;&amp; (!wall_up) ){  //bottom left corner
                                                                               //      |
                                                                               //      |
                                                                               //      |-----
            if (last_direction == col_down) my_dir = col_right;
            else my_dir = col_up;
            set_path_logic = false;
        }
    }
    
    if (wall_count == 3){
        // 3 open-----------------------------
    
        if ( (!wall_right) &amp;&amp; (wall_down) &amp;&amp; (!wall_left) &amp;&amp; (!wall_up) ){
                                                                               //      |
                                                                               //      |
                                                                               //  ----|-----
            if ( (last_direction == col_down) &amp;&amp; (x &lt; obj_home.x) ) my_dir = col_right;
            else if ( (last_direction == col_down) &amp;&amp; (x &gt; obj_home.x) ) my_dir = col_left;
            else if ( (last_direction == col_right) &amp;&amp; (y &gt; obj_home.y) ) my_dir = col_up;
            else if ( (last_direction == col_right) &amp;&amp; (y &lt; obj_home.y) ) my_dir = col_right;
            else if ( (last_direction == col_left) &amp;&amp; (y &gt; obj_home.y) ) my_dir = col_up;
            else if ( (last_direction == col_left) &amp;&amp; (y &lt; obj_home.y) ) my_dir = col_left;
            set_path_logic = false;
        }
        
        
        else if ( (!wall_right) &amp;&amp; (!wall_down) &amp;&amp; (!wall_left) &amp;&amp; (wall_up) ){
                                                                               //  ----|-----
                                                                               //      |
                                                                               //      |
            if ( (last_direction == col_up) &amp;&amp; (x &lt; obj_home.x) ) my_dir = col_right;
            else if ( (last_direction == col_up) &amp;&amp; (x &gt; obj_home.x) ) my_dir = col_left;
            else if ( (last_direction == col_right) &amp;&amp; (y &gt; obj_home.y) ) my_dir = col_right;
            else if ( (last_direction == col_right) &amp;&amp; (y &lt; obj_home.y) ) my_dir = col_down;
            else if ( (last_direction == col_left) &amp;&amp; (y &gt; obj_home.y) ) my_dir = col_left;
            else if ( (last_direction == col_left) &amp;&amp; (y &lt; obj_home.y) ) my_dir = col_down;
            set_path_logic = false;
        }
        
        
        
        else if ( (!wall_right) &amp;&amp; (!wall_down) &amp;&amp; (wall_left) &amp;&amp; (!wall_up) ){
                                                                               //      |
                                                                               //      |-----
                                                                               //      |
            if ( (last_direction == col_up) &amp;&amp; (x &lt; obj_home.x) ) my_dir = col_right;
            else if ( (last_direction == col_up) &amp;&amp; (x &gt; obj_home.x) ) my_dir = col_up;
            else if ( (last_direction == col_down) &amp;&amp; (x &gt; obj_home.x) ) my_dir = col_down;
            else if ( (last_direction == col_down) &amp;&amp; (x &lt; obj_home.x) ) my_dir = col_right;
            else if ( (last_direction == col_left) &amp;&amp; (y &gt; obj_home.y) ) my_dir = col_up;
            else if ( (last_direction == col_left) &amp;&amp; (y &lt; obj_home.y) ) my_dir = col_down;
            set_path_logic = false;
        }
        
        
        
        
        else if ( (wall_right) &amp;&amp; (!wall_down) &amp;&amp; (!wall_left) &amp;&amp; (!wall_up) ){
                                                                               //      |
                                                                               // -----|
                                                                               //      |
            if ( (last_direction == col_up) &amp;&amp; (x &lt; obj_home.x) ) my_dir = col_up;
            else if ( (last_direction == col_up) &amp;&amp; (x &gt; obj_home.x) ) my_dir = col_left;
            else if ( (last_direction == col_right) &amp;&amp; (y &gt; obj_home.y) ) my_dir = col_up;
            else if ( (last_direction == col_right) &amp;&amp; (y &lt; obj_home.y) ) my_dir = col_down;
            else if ( (last_direction == col_down) &amp;&amp; (x &gt; obj_home.x) ) my_dir = col_left;
            else if ( (last_direction == col_down) &amp;&amp; (x &lt; obj_home.x) ) my_dir = col_down;
            set_path_logic = false;
        }   
    }
    
    
    //wall in every direction!
    else if ( (!wall_right) &amp;&amp; (!wall_down) &amp;&amp; (!wall_left) &amp;&amp; (!wall_up) ){

        //teleport back to beginning
        x = starting_position_x;
        y = starting_position_y;
        my_path.x = x;
        my_path.y = y;
                
        set_path_logic = false;
    }
    
    
    
    set_path_logic = false;
}



if ( (!wall_right) &amp;&amp; (!wall_down) &amp;&amp; (!wall_left) &amp;&amp; (!wall_up) ){

        //teleport back to beginning
        x = starting_position_x;
        y = starting_position_y;
        my_path.x = x;
        my_path.y = y;
}



var rand_main = choose(0) //variance on movement
var rand_minor = choose(0) //minor variance on movement


//if the pathfind gets too far:
if ( (distance_to_point(my_path.x, my_path.y)) &gt; move_speed*2){
    my_path.x = x;
    my_path.y = y;
}






//store this for advanced logic
if (!last_direction == my_dir) last_direction = my_dir;



//move the pathfind object
if (set_direction == true){
    switch (my_dir){  
        case col_right: 
            my_path.x += move_speed + rand_main;
            my_path.y += rand_minor;
            break;
            
        case col_down: 
            my_path.y += move_speed + rand_main;
            my_path.x += rand_minor;
            break;
            
        case col_left: 
            my_path.x -= move_speed + rand_main;
            my_path.y += rand_minor;
            break;
            
        case col_up: 
            my_path.y -= move_speed + rand_main;
            my_path.x += rand_minor;
            break;
            
        default:
            break;
    }
}

*/

//alarm[0] = col_check; //reset the alarm. See macros for the constant number
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///new version



if (!global.freeze) {
    
    var rand_main = choose(-2,-1,0,2,4) //variance on movement
    var rand_minor = choose(-2,-1,0,1,2) //minor variance on movement
    
    if (!fighting &amp;&amp; looking_for_fight) {
    
        //if the pathfind gets too far:
        if ( (distance_to_point(my_path.x, my_path.y)) &gt; move_distance*2){
            my_path.x = x;
            my_path.y = y;
        }
        
        
        if (place_meeting(x, y, obj_tile_right)) {
            my_path.x += move_distance  + sprinter_amount + rand_main;
            my_path.y += rand_minor;
        }
        
        else if (place_meeting(x, y, obj_tile_down)) {
            my_path.y += move_distance + sprinter_amount + rand_main;
            my_path.x += rand_minor; 
        }
        
        else if (place_meeting(x, y, obj_tile_left)) {
            my_path.x -= move_distance + sprinter_amount + rand_main;
            my_path.y += rand_minor;
        }
        
        else if (place_meeting(x, y, obj_tile_up)) {
            my_path.y -= move_distance + sprinter_amount + rand_main;
            my_path.x += rand_minor;
        }
        
        
        //corners
        
        //move down
        else if (place_meeting(x, y, obj_tile_leftdown)) || (place_meeting(x, y, obj_tile_rightdown)) {
            my_path.y += move_distance + sprinter_amount + rand_main;
            my_path.x += rand_minor;
        }
        
        //move left
        else if (place_meeting(x, y, obj_tile_downleft)) || (place_meeting(x, y, obj_tile_upleft)) {
            my_path.y += rand_minor;
            my_path.x -= move_distance + sprinter_amount + rand_main; 
        }
        
        //move right
        else if (place_meeting(x, y, obj_tile_downright)) || (place_meeting(x, y, obj_tile_upright)) {
            my_path.y += rand_minor;
            my_path.x += move_distance + sprinter_amount + rand_main;
        }
        
        //move up
        else if (place_meeting(x, y, obj_tile_leftup)) || (place_meeting(x, y, obj_tile_rightup)) {
            my_path.y -= move_distance + sprinter_amount + rand_main;
            my_path.x += rand_minor;
        }
    
    }
    
    //if sprinting, create sprint faders:
    if (draw_sprint_icon) {
        my_sprint_trail = instance_create(x,y,obj_sprint_trail);
        my_sprint_trail.my_sprite = my_sprite;
        my_sprint_trail.my_scale = sprite_scale;
        my_sprint_trail.my_color = my_color;
    }
    
    
    //update the priority to units ahead in the path sequence, based on the path tile they are standing on:
    
    if (position_meeting(x, y, obj_tile_parent)) {
        var current_tile = instance_position(x,y,obj_tile_parent); //currently only checks at position x,y and not collisions using the sprite
        tile_currently_on = current_tile.path0_sequence;
    }
    
    
    store_path_x = my_path.x;
    store_path_y = my_path.y;
    
}
                //no faster than 5 for the alarm
    alarm[0] = max(my_move_speed - sprinter_amount*3, 5) + stun_duration; //reset the alarm. See macros for the constant number
    


</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>
if (!global.freeze) {

    //destroy all enemies on screen. Testing purposes. 
    //if (keyboard_check_pressed(vk_space)) instance_destroy();
    
    if (my_health &lt;= 0) {
        killed_by_tower = true;
        
        if (fighting &amp;&amp; instance_exists(obj_barracks_unit)){
            my_hero_target.looking_for_fight = true;
            my_hero_target.fighting = false;
        }
        
        instance_destroy();
    }
    
    
    
    if (!is_dead){
    
        x = ease(x, my_path.x, 0.1);
        y = ease(y, my_path.y, 0.1);
        
        if check_shield {
            allow_draw_shield = true;
            if (add_shield){
                armor = base_armor + hoard_amount + round(base_armor*0.2) + 5;
            }
            else armor = base_armor + hoard_amount;
            check_shield = false;
        }
        
        
        if (create_indicator) {
            my_treasure_indicator = instance_create(x, y-16, obj_treasure_indicator);
            my_treasure_indicator.follow_id = id;
            create_indicator = false;
        }
        
        if (is_treasure_enemy &amp;&amp; !indicator_destroyed) {
            my_treasure_indicator.x = x;
            my_treasure_indicator.y = y - 32;
        }
        
    
    }

}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>instance_destroy();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>
//if on fire, blend to orange:
if (fire_alarm &gt; 0) fire_alarm--;
fire_color_amount = fire_alarm/fire_alarm_max;

my_color = merge_colour(my_starting_color, c_orange, fire_color_amount);

//draw this under the enemy sprite for a glow effect
if (draw_sprint_icon) {
    sprinter_glow_alpha = ease(sprinter_glow_alpha, 0.2, 0.05);
    draw_sprite_ext(spr_dude_mask, image_index, x,y,sprite_scale + 0.3,sprite_scale + 0.3,0,c_white, sprinter_glow_alpha);
} 

else {
    sprinter_glow_alpha = ease(sprinter_glow_alpha, 0, 0.05);
    draw_sprite_ext(spr_dude_mask, image_index, x,y,sprite_scale + 0.3,sprite_scale + 0.3,0,c_white, sprinter_glow_alpha);
}

//draw the enemy:
draw_sprite_ext(my_sprite, image_index, x,y,sprite_scale,sprite_scale,0,my_color, 1);

var health_perc = my_health/max_health; //our percentage of health used for scaling


var healthbar_size_x = 48; //actual width of the health bar. 
var healthbar_scale = round(healthbar_size_x*health_perc); //scales the bar to the correct size

var healthbar_size_y = 12; //actual height of the health bar
var healthbar_center = x - (healthbar_size_x/2); //center the bar above the monsters head

var above_head = 20;

//my health bar

//red
draw_set_alpha(0.3);
draw_rectangle_colour(healthbar_center, y - above_head, healthbar_center + healthbar_size_x, y - above_head - healthbar_size_y, c_red, c_red, c_red, c_red, false);

//green
draw_set_alpha(0.5);
draw_rectangle_colour(healthbar_center, y - above_head, healthbar_center + healthbar_scale, y - above_head - healthbar_size_y, c_green, c_green, c_green, c_green, false);

//outline
draw_set_alpha(1);
draw_rectangle(healthbar_center, y - above_head, healthbar_center + healthbar_size_x, y - above_head - healthbar_size_y, true); // outline



if (armor &gt; 0) {
    draw_set_font(ft_gold_supersmall);
    draw_text_color(x - string_width(string(armor))/2,y - above_head - 15, string(armor) ,c_aqua, c_aqua, c_aqua, c_aqua, 1)

    if (allow_draw_shield){ 
        if (add_shield){
            draw_sprite_ext(spr_shield, image_index, healthbar_center, y - above_head - 4, 0.65, 0.65, 0, c_white, 1);
        }
    }
}

if (allow_draw_heal) {
    draw_sprite_ext(spr_medic, image_index, x, y - 12, 0.25, 0.25, 0, c_white, 0.7);
}

if (allow_draw_hoard) {
    draw_sprite_ext(spr_hoard, image_index, x, y - above_head - 16, 0.4, 0.4, 0, c_white, 1);
}

//instead I could create a jumping sprite
if (stun_duration &gt; 0) {
    draw_sprite_ext(spr_stunned, image_index, x, y - above_head - 16, sprite_scale*0.75, sprite_scale*0.75, 0, c_white, 0.6);
}

if (draw_exclamation) {
    draw_sprite_ext(spr_exclam, image_index, x, y - above_head - 16, 1, 1, 0, c_white, 1);
}

//reset
draw_set_alpha(1);


//old
/*
if (shielder) {
    draw_sprite_ext(spr_shield, image_index, x, y, 1, 1, 0, c_yellow, 0.8);
}

*/


</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
