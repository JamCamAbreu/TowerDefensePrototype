<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_tower_oil</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-20</depth>
  <persistent>0</persistent>
  <parentName>obj_tower_parent</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>draw_range_circle = 0;

sell_amount = 10; //later changed when constructed

total_upgrade_count = 0;

unselected_depth = round(depth - y/16);
depth = unselected_depth;

selected_depth = unselected_depth - 10;

choose_banner = irandom(8);

//local_tower_id (this variable is given to this object in con_room when the tower is purchased and then placed. 

tower_cur_range = tower_oil_start_range;
//range_upgrade_amount = 20;
//range_upgrade_cost = 25;
//range_iterations = 0;

rate_of_fire = con_room.tower_rock_start_speed;
//speed_upgrade_amount = 6;
//speed_upgrade_cost = 35;
//speed_iterations = 0;

tower_damage = con_room.tower_rock_start_damage;
//damage_upgrade_amount = 5;
//damage_upgrade_cost = 15;
//damage_iterations = 0;

oil_duration = con_room.tower_oil_start_burn_duration; //frames
oil_upgrade_amount = 60;
oil_upgrade_cost = 240;
oil_iterations = 0;

fire_size = 1; //sprite size
fire_upgrade_amount = 0.3;
fire_upgrade_cost = 180;
fire_iterations = 0;


tower_projectile_speed = 12;


tower_name = "Oil and Flame";

tower_nickname = random_name();

my_built_string = instance_create(x,y-16,obj_built_string);
my_built_string.name = tower_nickname;
my_built_string.my_tower = id;
draw_nickname = false;

alarm[0] = 30;

//testing purposes:
iterations = 0;

//initialize the target
enemy_pointer = 0;
has_target = false; 
my_target = 0;
distance_to_last_target = tower_cur_range;

my_draw_alpha = 0;

//make it illegal to place a tower on another tower
my_tower_spot = instance_create(x,y - 32,obj_tower_spot);

display_upgrades = false;

first_drawn = false;




</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>
if (!global.freeze) {

    //reset the target
    enemy_pointer = 0;
    has_target = false; 
    my_target = 0;
    my_target_exists_pointer = 0;
    distance_to_last_target = tower_cur_range;
    
    enemy_priority = 0; //reset
    enemy_priority_last = 0;
    
    //Enemy Cycling:
    for (enemy_pointer = 0; enemy_pointer &lt; global.map_cur_enemy; enemy_pointer++){
        //cycle through each enemy
    
        
        if (global.enemy_id_exists[enemy_pointer] = true){ //skip this if the object does not exist any longer. (stored in a seperate boolean array)
            distance_to_pointer = distance_to_point(global.enemy_id[enemy_pointer].x, global.enemy_id[enemy_pointer].y);
                
            //check the tile that the unit is on (higher numbers for closer to home object
            enemy_priority = global.enemy_id[enemy_pointer].tile_currently_on;
                
            if ( (distance_to_pointer &lt; tower_cur_range) &amp;&amp; (enemy_priority &gt; enemy_priority_last) ) {
            
                //if within range and closer to the obj. home
                my_target = global.enemy_id[enemy_pointer].id;
                enemy_priority_last = enemy_priority;
                
                has_target = true;   
                my_target_exists_pointer = enemy_pointer //helps the bullets to destroy themselves when target does not exist any more. 
            }
            
            //target closest enemy
            /*
            if ( (distance_to_pointer &lt; tower_cur_range) &amp;&amp; (distance_to_pointer &lt; distance_to_last_target) ){ //nearest enemy to tower
                
        
                //if within range and smaller distance then last target:
                my_target = global.enemy_id[enemy_pointer].id;
                has_target = true;   
                distance_to_last_target = distance_to_pointer;
                my_target_exists_pointer = enemy_pointer //helps the bullets to destroy themselves when target does not exist any more. 
            }
            */
            
            
        }
    }
    
    
    //iterations++; //for debugging
    
    
    if (has_target) {
    
        my_missile = instance_create(x, y - 32, obj_bullet);
        //make it a fire bullet:
        my_missile.is_fire_bullet = true;
        
        my_missile.missile_target = my_target.id;
        my_missile.missile_speed = tower_projectile_speed;
        my_missile.missile_damage = tower_damage;
        my_missile.enemy_pointer = my_target_exists_pointer;//helps the bullets to destroy themselves when target does not exist any more. 
        
        my_missile.last_known_x = my_target.store_path_x;
        my_missile.last_known_y = my_target.store_path_y;
        
        
        my_missile.fire_alarm_max = oil_duration;
        my_missile.fire_size = fire_size;
        
        global.shots_fired++;
    }

}

alarm[0] = rate_of_fire;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/*
//start a little dark, brighten with upgrades:
var my_merge_color_amount = total_upgrade_count*0.05;
var my_merge_color_upgrade_total = merge_colour(c_white, c_dkgray, my_merge_color_amount);

//add red for damage
var add_damage = damage_iterations*0.1;
var my_merge_add_damage = merge_colour(my_merge_color_upgrade_total, c_red, add_damage);

//add green for range
var add_range = range_iterations*0.1;
var my_merge_add_range = merge_colour(my_merge_add_damage, c_lime, add_range);

//add blue for speed
var add_speed = speed_iterations*0.1;
var my_merge_add_speed = merge_colour(my_merge_add_range, c_aqua, add_speed);

var my_merge_color = my_merge_add_speed;

draw_sprite_ext(spr_tower_oil, image_index, x,y,1,1,0,my_merge_color,1);
*/

//just draw this tower normally. No upgrades. Just abilities
draw_sprite_ext(spr_tower_oil, image_index, x,y,1,1,0,c_white,1);


var my_color_yellow = make_color_hsv(25,240,120);
var my_color_orange = make_color_hsv(25,240,140);



//only draw when the mouse is over the object
if (place_meeting( x, y, obj_mouse_tip)) &amp;&amp; (!global.hover_over_upgrade){    

    my_draw_alpha = ease(my_draw_alpha, 0.2, 0.1)
    draw_set_alpha(my_draw_alpha);

    //update the range circle
    draw_range_circle = ease(draw_range_circle, tower_cur_range, 0.2);
    draw_circle_colour(x, y, draw_range_circle, c_lime, c_lime, false);
    
    draw_sprite_ext(spr_tower_oil, image_index, x,y,1,1,0,c_white,1);

    //draw_name on mouse hover over
    if (draw_nickname) {
    draw_set_font(ft_gold);
    
    var my_string = string(tower_nickname);
    var my_y = y - string_height(tower_nickname) + 32;
    
    draw_text_colour(x - (string_width(my_string)/2) + 2, my_y + 2, my_string, c_black, c_black, c_black, c_black, 1);
    draw_text_colour(x - (string_width(my_string)/2), my_y, my_string, my_color_yellow, my_color_yellow, my_color_orange, my_color_orange, 1);
        
    }
    
    
    draw_set_alpha(1); //reset alpha
    
}
else {
    my_draw_alpha = ease(my_draw_alpha, 0, 0.1);
    
    if (!con_UI.first_selected_tower)
        draw_range_circle = ease(draw_range_circle, 0, 0.3);
}



if (global.selected_tower_id = id) &amp;&amp; (con_UI.first_selected_tower) {

    depth = selected_depth;
    
        //also draw the range if the mouse is not hovering over it already:
        draw_set_alpha(0.2);
        
        draw_range_circle = ease(draw_range_circle, tower_cur_range, 0.2);
        draw_circle_colour(x, y, draw_range_circle, c_lime, c_lime, false);

        draw_set_alpha(1); //reset alpha
        
        draw_sprite_ext(spr_tower_oil, image_index, x,y,1,1,0,c_white,1);
    
    if (!place_meeting( x, y, obj_mouse_tip)) {

    }
    
    //draw name
    if (draw_nickname) {
        draw_set_font(ft_gold);
        
        var my_string = string(tower_nickname);
        var my_y = y - string_height(tower_nickname) + 32;
        
        draw_text_colour(x - (string_width(my_string)/2) + 2, my_y + 2, my_string, c_black, c_black, c_black, c_black, 1);
        draw_text_colour(x - (string_width(my_string)/2), my_y, my_string, my_color_yellow, my_color_yellow, my_color_orange, my_color_orange, 1);
    }
    
    
    //draw upgrades if they haven't been drawn yet:
    
    if (!display_upgrades) {
        
        var unit = 32 + 16;
        var height1 = max(0, y - unit*2);
        var height2 = max(0, height1 - unit);
        
        var left = max(0, x - unit);
        var right = max(0 + unit*2, x + unit);
        var center = max(0 + unit, x);
        
        //later make these locations to being their destiny:
        
        my_oil_upgrade = instance_create(x, y, obj_upgrade);
        my_oil_upgrade.target_x = left;
        my_oil_upgrade.target_y = height1;
        my_oil_upgrade.upgrade_type = oil;
        
        my_fire_upgrade = instance_create(x, y, obj_upgrade);
        my_fire_upgrade.target_x = right;
        my_fire_upgrade.target_y = height1;
        my_fire_upgrade.upgrade_type = fire_upgrade;
        
        display_upgrades = true;
        first_drawn = true;
    }
    
    //UPDATE EACH UPGRADE SPRITE TO SHOW THE CORRECT COST!
    //careful about this later...when I add the sell tower feature back?
    if (first_drawn) {
    
    //oil update:
        my_oil_upgrade.my_upgrade_cost = oil_upgrade_cost;
        my_oil_upgrade.upgrade_amount = oil_upgrade_amount;
        my_oil_upgrade.iterations = oil_iterations;
        
        
    //fire update:
        my_fire_upgrade.my_upgrade_cost = fire_upgrade_cost;
        my_fire_upgrade.upgrade_amount = fire_upgrade_amount;
        my_fire_upgrade.iterations = fire_iterations;
    }
    
    
}
else depth = unselected_depth;


draw_sprite_ext(spr_banner, choose_banner, x,y,1,1,0,c_white, 1);


//draw_text(x,y-64, string(total_upgrade_count));


//DEBUGGING
/*
draw_text(x - 8,y - 16, "has target = " + string(has_target));

if (has_target) draw_text(x - 8,y - 16*3, "my_target.x = " + string(my_target.x));

draw_text(x - 8,y - 16*4, "iterations = " + string(iterations));

*/
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
