<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_tower_normal</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-20</depth>
  <persistent>0</persistent>
  <parentName>obj_clickable</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>
total_upgrade_count = 0;

unselected_depth = round(depth - y/16);
depth = unselected_depth;

selected_depth = unselected_depth - 10;

choose_banner = irandom(8);

//local_tower_id (this variable is given to this object in con_room when the tower is purchased and then placed. 

tower_cur_range = tower_start_range;
range_upgrade_amount = 20;
range_upgrade_cost = 25;
range_iterations = 0;

rate_of_fire = 35;
speed_upgrade_amount = 6;
speed_upgrade_cost = 35;
speed_iterations = 0;

tower_damage = 8;
damage_upgrade_amount = 5;
damage_upgrade_cost = 15;
damage_iterations = 0;




tower_projectile_speed = 8;


tower_name = "Red Tower";

sell_amount = 10; //will change depending on upgrades.  

tower_nickname = random_name();

my_built_string = instance_create(x,y-16,obj_built_string);
my_built_string.name = tower_nickname;
my_built_string.my_tower = id;
draw_nickname = false;

alarm[0] = rate_of_fire;

//testing purposes:
iterations = 0;

//initialize the target
enemy_pointer = 0;
has_target = false; 
my_target = 0;
distance_to_last_target = tower_cur_range;

my_draw_alpha = 0;

//make it illegal to place a tower on another tower
instance_create(x,y - 32,obj_tower_spot);

display_upgrades = false;

first_drawn = false;




</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>
//reset the target
enemy_pointer = 0;
has_target = false; 
my_target = 0;
my_target_exists_pointer = 0;
distance_to_last_target = tower_cur_range;


//Enemy Cycling:
for (enemy_pointer = 0; enemy_pointer &lt; global.map_cur_enemy; enemy_pointer++){
    //cycle through each enemy

    
    if (global.enemy_id_exists[enemy_pointer] = true){ //skip this if the object does not exist any longer. (stored in a seperate boolean array)
            distance_to_pointer = distance_to_point(global.enemy_id[enemy_pointer].x, global.enemy_id[enemy_pointer].y);
            
        if ( (distance_to_pointer &lt; tower_cur_range) &amp;&amp; (distance_to_pointer &lt; distance_to_last_target) ){ //nearest enemy to tower
            
    
            //if within range and smaller distance then last target:
            my_target = global.enemy_id[enemy_pointer].id;
            has_target = true;   
            distance_to_last_target = distance_to_pointer;
            my_target_exists_pointer = enemy_pointer //helps the bullets to destroy themselves when target does not exist any more. 
        }
    }
}


//iterations++; //for debugging


if (has_target) {

    my_missile = instance_create(x, y - 32, obj_bullet);
    my_missile.missile_target = my_target.id;
    my_missile.missile_speed = tower_projectile_speed;
    my_missile.missile_damage = tower_damage;
    my_missile.enemy_pointer = my_target_exists_pointer;//helps the bullets to destroy themselves when target does not exist any more. 
    
    global.shots_fired++;
}



alarm[0] = rate_of_fire;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>
//start a little dark, brighten with upgrades:
var my_merge_color_amount = total_upgrade_count*0.05;
var my_merge_color_upgrade_total = merge_colour(c_white, c_dkgray, my_merge_color_amount);

//add red for damage
var add_damage = damage_iterations*0.1;
var my_merge_add_damage = merge_colour(my_merge_color_upgrade_total, c_red, add_damage);

//add green for range
var add_range = range_iterations*0.1;
var my_merge_add_range = merge_colour(my_merge_add_damage, c_lime, add_range);

//add blue for speed
var add_speed = speed_iterations*0.1;
var my_merge_add_speed = merge_colour(my_merge_add_range, c_aqua, add_speed);

var my_merge_color = my_merge_add_speed;

draw_sprite_ext(spr_tower_normal, image_index, x,y,1,1,0,my_merge_color,1);

var my_color_yellow = make_color_hsv(25,240,120);
var my_color_orange = make_color_hsv(25,240,140);



//only draw when the mouse is over the object
if (place_meeting( x, y, obj_mouse_tip)) &amp;&amp; (!global.hover_over_upgrade){

    

    my_draw_alpha = ease(my_draw_alpha, 0.2, 0.1)
    draw_set_alpha(my_draw_alpha);
    draw_circle_colour(x, y, tower_cur_range, c_lime, c_lime, false);
    
    draw_sprite_ext(spr_tower_normal, image_index, x,y,1,1,0,my_merge_color,1);

    //draw_name on mouse hover over
    if (draw_nickname) {
    draw_set_font(ft_gold);
    
    var my_string = string(tower_nickname);
    var my_y = y - string_height(tower_nickname) + 32;
    
    draw_text_colour(x - (string_width(my_string)/2) + 2, my_y + 2, my_string, c_black, c_black, c_black, c_black, 0.5);
    draw_text_colour(x - (string_width(my_string)/2), my_y, my_string, my_color_yellow, my_color_yellow, my_color_orange, my_color_orange, 0.5);
        
    }
    
    
    draw_set_alpha(1); //reset alpha
    
}
else my_draw_alpha = ease(my_draw_alpha, 0, 0.1);




if (global.selected_tower_id = id) &amp;&amp; (con_UI.first_selected_tower) {

    depth = selected_depth;
    draw_sprite(spr_tower_selected,image_index,x,y);
    
        //also draw the range if the mouse is not hovering over it already:
        draw_set_alpha(0.2);
        draw_circle_colour(x, y, tower_cur_range, c_lime, c_lime, false);
        draw_set_alpha(1); //reset alpha
        
        draw_sprite_ext(spr_tower_normal, image_index, x,y,1,1,0,my_merge_color,1);
    
    if (!place_meeting( x, y, obj_mouse_tip)) {

    }
    
    //draw name
    if (draw_nickname) {
        draw_set_font(ft_gold);
        
        var my_string = string(tower_nickname);
        var my_y = y - string_height(tower_nickname) + 32;
        
        draw_text_colour(x - (string_width(my_string)/2) + 2, my_y + 2, my_string, c_black, c_black, c_black, c_black, 1);
        draw_text_colour(x - (string_width(my_string)/2), my_y, my_string, my_color_yellow, my_color_yellow, my_color_orange, my_color_orange, 1);
    }
    
    
    //draw upgrades if they haven't been drawn yet:
    
    if (!display_upgrades) {
        
        var unit = 64 + 16;
        var height1 = y - unit;
        var height2 = height1 - unit/2;
        
        var left = x - unit;
        var right = x + unit;
        var center = x;
        
        //later make these locations to being their destiny:
        
        my_damage_upgrade = instance_create(x, y, obj_upgrade);
        my_damage_upgrade.target_x = left;
        my_damage_upgrade.target_y = height1;
        my_damage_upgrade.upgrade_type = swords;
        
        my_range_upgrade = instance_create(x, y, obj_upgrade);
        my_range_upgrade.target_x = center;
        my_range_upgrade.target_y = height2;
        my_range_upgrade.upgrade_type = longbow;
        
        my_speed_upgrade = instance_create(x, y, obj_upgrade);
        my_speed_upgrade.target_x = right;
        my_speed_upgrade.target_y = height1;
        my_speed_upgrade.upgrade_type = feather;
        
        display_upgrades = true;
        first_drawn = true;
    }
    
    //UPDATE EACH UPGRADE SPRITE TO SHOW THE CORRECT COST!
    //careful about this later...when I add the sell tower feature back?
    if (first_drawn) {
    
    //damage update:
        my_damage_upgrade.my_upgrade_cost = damage_upgrade_cost;
        my_damage_upgrade.upgrade_amount = damage_upgrade_amount;
        my_damage_upgrade.iterations = damage_iterations;
        
    //range update: 
        my_range_upgrade.my_upgrade_cost = range_upgrade_cost;
        my_range_upgrade.upgrade_amount = range_upgrade_amount;
        my_range_upgrade.iterations = range_iterations;
        
    //speed update:
        my_speed_upgrade.my_upgrade_cost = speed_upgrade_cost;
        my_speed_upgrade.upgrade_amount = speed_upgrade_amount;
        my_speed_upgrade.iterations = speed_iterations;
    }
    
    
}
else depth = unselected_depth;

draw_sprite_ext(spr_banner, choose_banner, x,y - 32,1,1,0,c_white, 1);


//draw_text(x,y-64, string(total_upgrade_count));


//DEBUGGING
/*
draw_text(x - 8,y - 16, "has target = " + string(has_target));

if (has_target) draw_text(x - 8,y - 16*3, "my_target.x = " + string(my_target.x));

draw_text(x - 8,y - 16*4, "iterations = " + string(iterations));

*/
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
